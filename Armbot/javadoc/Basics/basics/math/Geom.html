<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (13) on Wed Feb 22 12:31:17 CET 2023 -->
<title>Geom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2023-02-22">
<meta name="description" content="declaration: module: Basics, package: basics.math, class: Geom">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":9,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":9,"i90":9,"i91":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="moduleLabelInType">Module</span>&nbsp;<a href="../../module-summary.html">Basics</a></div>
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">basics.math</a></div>
<h1 title="Class Geom" class="title">Class Geom</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">basics.math.Geom</div>
</div>
<section class="description">
<hr>
<pre>public class <span class="typeNameLabel">Geom</span>
extends java.lang.Object</pre>
<div class="block">Geometric functions.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>J&ouml;rg Roth (<a href="mailto:Joerg.Roth@Wireless-earth.org">Joerg.Roth@Wireless-earth.org</a>)</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aboveTriangle3D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">aboveTriangle3D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is above a 3D triangle.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#aboveTriangle3D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,double)">aboveTriangle3D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point,
double&nbsp;epsilon)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is above, below or on a 3D triangle.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#absDiffRadians(double,double)">absDiffRadians</a></span>&#8203;(double&nbsp;a1,
double&nbsp;a2)</code></th>
<td class="colLast">
<div class="block">Same as <a href="#diffRadians(double,double)"><code>diffRadians(double,double)</code></a>, but takes the absolute value of angle difference.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#abTriangle2D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">abTriangle2D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute for a triangle with point p1, p2, p3 and a given point p, the relations a, b where<br>
 p=a&middot;(p2-p1)+b&middot;(p3-p1).<br>
 This method does <i>not</i> check, if a point is inside the triangle, i.e. a&ge;0, b&ge;0, a+b&le;1.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#abTriangle2Dprecomp(double%5B%5D,double%5B%5D)">abTriangle2Dprecomp</a></span>&#8203;(double[]&nbsp;precomp,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute for a triangle with point p1, p2, p3 and a given point p, the relations a, b where<br>
 p=a&middot;(p2-p1)+b&middot;(p3-p1).<br>
 This method does <i>not</i> check, if a point is inside the triangle, i.e. a&ge;0, b&ge;0, a+b&le;1.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#angXYangXZtoMapPositions(double%5B%5D,double%5B%5D)">angXYangXZtoMapPositions</a></span>&#8203;(double[]&nbsp;a,
double[]&nbsp;b)</code></th>
<td class="colLast">
<div class="block">Compute the rotation XY (yaw) and XZ (pitch) to map two positions, when the ordering is
 
  first in the x-y plane
  then in the x-z plane
  
 In particular, the rotation YZ (roll) must be 0.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#angXYangXZtoMapPositionsReverse(double%5B%5D,double%5B%5D)">angXYangXZtoMapPositionsReverse</a></span>&#8203;(double[]&nbsp;a,
double[]&nbsp;b)</code></th>
<td class="colLast">
<div class="block">Compute the rotation XY (yaw) and XZ (pitch) to map two positions, when the ordering is
 
  first in the x-z plane
  then in the x-y plane
  (note, this is reverse to <a href="#angXYangXZtoMapPositions(double%5B%5D,double%5B%5D)"><code>angXYangXZtoMapPositions(double[],double[])</code></a>.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#arcBetweenPoses(double,double,double,double,double,double)">arcBetweenPoses</a></span>&#8203;(double&nbsp;sx,
double&nbsp;sy,
double&nbsp;sang,
double&nbsp;tx,
double&nbsp;ty,
double&nbsp;tang)</code></th>
<td class="colLast">
<div class="block">Compute an arc (center, rad) from two poses (start, targe).</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#areaSize2D(double%5B%5D%5B%5D)">areaSize2D</a></span>&#8203;(double[][]&nbsp;polygon)</code></th>
<td class="colLast">
<div class="block">Compute the area size of the ground projected polygon.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#areaSize2Dsigned(double%5B%5D%5B%5D)">areaSize2Dsigned</a></span>&#8203;(double[][]&nbsp;polygon)</code></th>
<td class="colLast">
<div class="block">Compute the area size of the ground projected polygon.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bisectings(double,double)">bisectings</a></span>&#8203;(double&nbsp;a1,
double&nbsp;a2)</code></th>
<td class="colLast">
<div class="block">Computes the bisectings between two angles, i.e. the angles with the same difference to both angles.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#circleCenterFromThreePoints(double,double,double,double,double,double)">circleCenterFromThreePoints</a></span>&#8203;(double&nbsp;x1,
double&nbsp;y1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;x3,
double&nbsp;y3)</code></th>
<td class="colLast">
<div class="block">Computes a circle center by three points that reside on this circle.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#circleForTangentPointAndCircle(double,double,double,double,double,double,double)">circleForTangentPointAndCircle</a></span>&#8203;(double&nbsp;cx,
double&nbsp;cy,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;tx,
double&nbsp;ty)</code></th>
<td class="colLast">
<div class="block">Given a circle with center c and radius r; further a point p and tangent vector t.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#circlesForTangentAndCircle(double,double,double,double,double,double,double,double)">circlesForTangentAndCircle</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;cxcircle,
double&nbsp;cycircle,
double&nbsp;rcircle,
double&nbsp;r)</code></th>
<td class="colLast">
<div class="block">Given a straight line p+i&middot;m and circle c<sub>xcircle</sub>, c<sub>ycircle</sub> with radius r<sub>circle</sub>, 
 further a radius r for result circles.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#circlesForTwoTangents(double,double,double,double,double,double,double,double,double)">circlesForTwoTangents</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny,
double&nbsp;r)</code></th>
<td class="colLast">
<div class="block">Given two straight lines p+i&middot;m and q+j&middot;n and radius r.</div>
</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#convexHull2D(double%5B%5D%5B%5D)">convexHull2D</a></span>&#8203;(double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Compute a convex hull of 2D points using <i>Andrew's monotone chain convex hull algorithm</i>.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createConvexPolygon(java.util.ArrayList,int,int)">createConvexPolygon</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points,
int&nbsp;dimension1,
int&nbsp;dimension2)</code></th>
<td class="colLast">
<div class="block">Create a convex polygon from a list of unsorted points (that belong to a convex polygon).<br>
 <i>Important: </i> this method does not execute a convex-hull approach to remove 'inner' points.<br>
 The approach requires the definition of two dimensions.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createRightangledTriangle(double,double,double,double,double)">createRightangledTriangle</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;r)</code></th>
<td class="colLast">
<div class="block">Create a right-angled triangle with some conditions:
 Two of the three points, namely p<sub>1</sub>, p<sub>2</sub> are given.
 The third point s should be computed.
 The distance between s and p<sub>2</sub> is given as r&gt;0.
 The right angle is in s, i.e. between the edges p<sub>1</sub> - s and p<sub>2</sub> - s.
 
 For r&gt;0 we get zero or two points s that fulfill these conditions.<br>
 We can have another view on the problem.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cutHorizontalSweepLine(double,double,double,double,double,double)">cutHorizontalSweepLine</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny)</code></th>
<td class="colLast">
<div class="block">Computes the intersection of the horizontal sweep line p+i&middot;(1,0) and straight line q+j&middot;n.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cutLines(double,double,double,double,double,double,double,double)">cutLines</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny)</code></th>
<td class="colLast">
<div class="block">Computes the intersection of two straight lines p+i&middot;m and q+j&middot;n.</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cutLineSegments(double,double,double,double,double,double,double,double)">cutLineSegments</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;q1x,
double&nbsp;q1y,
double&nbsp;q2x,
double&nbsp;q2y)</code></th>
<td class="colLast">
<div class="block">Computes the intersection of two line segments (p1,p2) and (q1,q2).</div>
</td>
</tr>
<tr class="rowColor" id="i21">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#diffRadians(double,double)">diffRadians</a></span>&#8203;(double&nbsp;a1,
double&nbsp;a2)</code></th>
<td class="colLast">
<div class="block">Computes the (signed) difference <i>a</i><sub>1</sub>-<i>a</i><sub>2</sub> of two angles <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>.</div>
</td>
</tr>
<tr class="altColor" id="i22">
<td class="colFirst"><code>static java.util.ArrayList&lt;double[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#douglasPeucker(double%5B%5D%5B%5D,double)">douglasPeucker</a></span>&#8203;(double[][]&nbsp;points,
double&nbsp;epsilon)</code></th>
<td class="colLast">
<div class="block">Performs the <i>Douglas Peucker</i> line simplifyer.</div>
</td>
</tr>
<tr class="rowColor" id="i23">
<td class="colFirst"><code>static java.util.ArrayList&lt;double[]&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#douglasPeucker(double%5B%5D%5B%5D,int,int,double)">douglasPeucker</a></span>&#8203;(double[][]&nbsp;points,
int&nbsp;fromIndex,
int&nbsp;toIndex,
double&nbsp;epsilon)</code></th>
<td class="colLast">
<div class="block">Performs the <i>Douglas Peucker</i> line simplifyer for a sub list of points.</div>
</td>
</tr>
<tr class="altColor" id="i24">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMBC(double%5B%5D%5B%5D)">getMBC</a></span>&#8203;(double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Get the minimal bounding cubic of all points in the list.</div>
</td>
</tr>
<tr class="rowColor" id="i25">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMBC(java.util.ArrayList)">getMBC</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Get the minimal bounding cubic of all points in the list.</div>
</td>
</tr>
<tr class="altColor" id="i26">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMBR(double%5B%5D%5B%5D)">getMBR</a></span>&#8203;(double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Get the minimal bounding rect of all points in the list.</div>
</td>
</tr>
<tr class="rowColor" id="i27">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getMBR(java.util.ArrayList)">getMBR</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Get the minimal bounding rect of all points in the list.</div>
</td>
</tr>
<tr class="altColor" id="i28">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getPlane(double%5B%5D%5B%5D)">getPlane</a></span>&#8203;(double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Compute the plane of a 3D polygon.</div>
</td>
</tr>
<tr class="rowColor" id="i29">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation2D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i30">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation2D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i31">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i32">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i33">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3DignoreZ</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i34">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3DignoreZ</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i35">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj2D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj2D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i36">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj2D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i37">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj3D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i38">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3D</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i39">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj3DignoreZ(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3DignoreZ</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="altColor" id="i40">
<td class="colFirst"><code>static <a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getRotoTranslationObj3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3DignoreZ</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</code></th>
<td class="colLast">
<div class="block">Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).</div>
</td>
</tr>
<tr class="rowColor" id="i41">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insidePolygon2D(double%5B%5D%5B%5D,double%5B%5D)">insidePolygon2D</a></span>&#8203;(double[][]&nbsp;polygon,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether the given point is inside the 2D polygon.</div>
</td>
</tr>
<tr class="altColor" id="i42">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insidePolygon2D(double%5B%5D%5B%5D,double%5B%5D,int,int)">insidePolygon2D</a></span>&#8203;(double[][]&nbsp;polygon,
double[]&nbsp;point,
int&nbsp;dimension1,
int&nbsp;dimension2)</code></th>
<td class="colLast">
<div class="block">Decide whether the given point is inside the 2D polygon.</div>
</td>
</tr>
<tr class="rowColor" id="i43">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insidePolygon3D(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D)">insidePolygon3D</a></span>&#8203;(double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is inside a 3D polygon.</div>
</td>
</tr>
<tr class="altColor" id="i44">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insideTriangle2D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">insideTriangle2D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is inside a 2D triangle.</div>
</td>
</tr>
<tr class="rowColor" id="i45">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insideTriangle2Dprecomp(double%5B%5D,double%5B%5D)">insideTriangle2Dprecomp</a></span>&#8203;(double[]&nbsp;precomp,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is inside a 2D triangle.</div>
</td>
</tr>
<tr class="altColor" id="i46">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#insideTriangle3D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">insideTriangle3D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Decide whether a given point is inside a 3D triangle.</div>
</td>
</tr>
<tr class="rowColor" id="i47">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectCircleSphere(double%5B%5D,double%5B%5D,double,double%5B%5D,double)">intersectCircleSphere</a></span>&#8203;(double[]&nbsp;cc,
double[]&nbsp;nc,
double&nbsp;rc,
double[]&nbsp;cs,
double&nbsp;rs)</code></th>
<td class="colLast">
<div class="block">Intersect a 3D circle with a sphere.</div>
</td>
</tr>
<tr class="altColor" id="i48">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectConvexPolygonPlane(double%5B%5D,double%5B%5D,double%5B%5D%5B%5D)">intersectConvexPolygonPlane</a></span>&#8203;(double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Compute the intersection of a plane and a convex 3D polygon.<br>
 <i>Note:</i> If the polygon is not convex, still a single intersection line segment is computed, even though the actual intersection would be multiple line segments.<br>
 <i>Further note:</i> It will not be checked, if the 3D polygon is in a plane.</div>
</td>
</tr>
<tr class="rowColor" id="i49">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectConvexPolygons2D(double%5B%5D%5B%5D,double%5B%5D%5B%5D)">intersectConvexPolygons2D</a></span>&#8203;(double[][]&nbsp;points1,
double[][]&nbsp;points2)</code></th>
<td class="colLast">
<div class="block">Compute the intersection polygon from two convex 2D polygons.</div>
</td>
</tr>
<tr class="altColor" id="i50">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectConvexPolygons2D(double%5B%5D%5B%5D,double%5B%5D%5B%5D,int,int)">intersectConvexPolygons2D</a></span>&#8203;(double[][]&nbsp;points1,
double[][]&nbsp;points2,
int&nbsp;dimension1,
int&nbsp;dimension2)</code></th>
<td class="colLast">
<div class="block">Compute the intersection polygon from two convex 2D polygons.<br>
 The caller can decide the coordinates that should be taken into account.<br>
 <i>Note: </i>It will not checked, if the input polygons are really convex.</div>
</td>
</tr>
<tr class="rowColor" id="i51">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectionRatioLineCircle(double,double,double,double,double,double,double)">intersectionRatioLineCircle</a></span>&#8203;(double&nbsp;cx,
double&nbsp;cy,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;dx,
double&nbsp;dy)</code></th>
<td class="colLast">
<div class="block">Intersects an infinite line with a circle.</div>
</td>
</tr>
<tr class="altColor" id="i52">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectionRatioLineSphere(double,double,double,double,double,double,double,double,double,double)">intersectionRatioLineSphere</a></span>&#8203;(double&nbsp;cx,
double&nbsp;cy,
double&nbsp;cz,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;pz,
double&nbsp;dx,
double&nbsp;dy,
double&nbsp;dz)</code></th>
<td class="colLast">
<div class="block">Intersects an infinite line with a sphere.</div>
</td>
</tr>
<tr class="rowColor" id="i53">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectLineCircle(double,double,double,double,double,double,double)">intersectLineCircle</a></span>&#8203;(double&nbsp;cx,
double&nbsp;cy,
double&nbsp;rad,
double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y)</code></th>
<td class="colLast">
<div class="block">Intersects an infinite line with a circle.</div>
</td>
</tr>
<tr class="altColor" id="i54">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectLinePlane(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">intersectLinePlane</a></span>&#8203;(double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[]&nbsp;linePoint,
double[]&nbsp;lineDirection)</code></th>
<td class="colLast">
<div class="block">Compute the intersection of line and plane (<a href="https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection">formula</a>).</div>
</td>
</tr>
<tr class="rowColor" id="i55">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectSpherePlane(double%5B%5D,double,double%5B%5D,double%5B%5D)">intersectSpherePlane</a></span>&#8203;(double[]&nbsp;sphereCenter,
double&nbsp;sphereRad,
double[]&nbsp;planePoint,
double[]&nbsp;planeNormal)</code></th>
<td class="colLast">
<div class="block">Intersect a sphere with a plane.</div>
</td>
</tr>
<tr class="altColor" id="i56">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectThreeSpheres(double%5B%5D,double,double%5B%5D,double,double%5B%5D,double)">intersectThreeSpheres</a></span>&#8203;(double[]&nbsp;p1,
double&nbsp;rad1,
double[]&nbsp;p2,
double&nbsp;rad2,
double[]&nbsp;p3,
double&nbsp;rad3)</code></th>
<td class="colLast">
<div class="block">Intersect three spheres.</div>
</td>
</tr>
<tr class="rowColor" id="i57">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectTwoCircles(double,double,double,double,double,double)">intersectTwoCircles</a></span>&#8203;(double&nbsp;x1,
double&nbsp;y1,
double&nbsp;r1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;r2)</code></th>
<td class="colLast">
<div class="block">Intersects two circles.</div>
</td>
</tr>
<tr class="altColor" id="i58">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectTwoConvexPolygons3DdifferentPlanes(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)">intersectTwoConvexPolygons3DdifferentPlanes</a></span>&#8203;(double[][]&nbsp;points1,
double[][]&nbsp;plane1,
double[][]&nbsp;points2,
double[][]&nbsp;plane2)</code></th>
<td class="colLast">
<div class="block">Compute the intersection two convex 3D polygons.<br>
 <i>Note:</i> If the polygon are not convex, still a single intersection line segment is computed, even though the actual intersection would be multiple line segments.<br>
 <i>Further note:</i> It will not be checked, if the 3D polygons are in their planes.</div>
</td>
</tr>
<tr class="rowColor" id="i59">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectTwoConvexPolygons3DsamePlane(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D%5B%5D)">intersectTwoConvexPolygons3DsamePlane</a></span>&#8203;(double[][]&nbsp;points1,
double[][]&nbsp;points2,
double[][]&nbsp;plane)</code></th>
<td class="colLast">
<div class="block">Compute the intersection polygon from two 3D convex polygons.</div>
</td>
</tr>
<tr class="altColor" id="i60">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#intersectTwoSpheres(double%5B%5D,double,double%5B%5D,double)">intersectTwoSpheres</a></span>&#8203;(double[]&nbsp;p1,
double&nbsp;rad1,
double[]&nbsp;p2,
double&nbsp;rad2)</code></th>
<td class="colLast">
<div class="block">Intersect two spheres.</div>
</td>
</tr>
<tr class="rowColor" id="i61">
<td class="colFirst"><code>static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isConvex(double%5B%5D%5B%5D)">isConvex</a></span>&#8203;(double[][]&nbsp;polygon)</code></th>
<td class="colLast">
<div class="block">Decide whether the ground projected polygon is convex.</div>
</td>
</tr>
<tr class="altColor" id="i62">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#joinMBRs(double%5B%5D,double%5B%5D)">joinMBRs</a></span>&#8203;(double[]&nbsp;mbr1,
double[]&nbsp;mbr2)</code></th>
<td class="colLast">
<div class="block">Computes two bounding rects to a new bounding rect; also may take null bounding rects.</div>
</td>
</tr>
<tr class="rowColor" id="i63">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#maxDescent(double,double)">maxDescent</a></span>&#8203;(double&nbsp;tiltAngleXZ,
double&nbsp;tiltAngleYZ)</code></th>
<td class="colLast">
<div class="block">Compute the direction of maximum descent from the two tilt (Euler) angles.</div>
</td>
</tr>
<tr class="altColor" id="i64">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#minRadiansBetweenLines(double,double)">minRadiansBetweenLines</a></span>&#8203;(double&nbsp;a1,
double&nbsp;a2)</code></th>
<td class="colLast">
<div class="block">Return the (absolute) smallest angle difference between two lines, given bei their line angles.</div>
</td>
</tr>
<tr class="rowColor" id="i65">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mostDistant(double%5B%5D%5B%5D)">mostDistant</a></span>&#8203;(double[][]&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Computes the pair of most distance points according to <a href="Matrix.html#distance(double%5B%5D,double%5B%5D)"><code>Matrix.distance(double[],double[])</code></a>.</div>
</td>
</tr>
<tr class="altColor" id="i66">
<td class="colFirst"><code>static int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mostDistant(java.util.ArrayList)">mostDistant</a></span>&#8203;(java.util.ArrayList&lt;double[]&gt;&nbsp;points)</code></th>
<td class="colLast">
<div class="block">Computes the pair of most distance points according to <a href="Matrix.html#distance(double%5B%5D,double%5B%5D)"><code>Matrix.distance(double[],double[])</code></a>.</div>
</td>
</tr>
<tr class="rowColor" id="i67">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestPlanePoint(double%5B%5D,double%5B%5D,double%5B%5D)">nearestPlanePoint</a></span>&#8203;(double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute the nearest point of the plane to a point.</div>
</td>
</tr>
<tr class="altColor" id="i68">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestPlanePoint(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D)">nearestPlanePoint</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute the nearest point of the plane to a point.</div>
</td>
</tr>
<tr class="rowColor" id="i69">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestPolygonPoint3D(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D)">nearestPolygonPoint3D</a></span>&#8203;(double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute to a given point the nearest point 3D that belongs to the convex polygon or its area.</div>
</td>
</tr>
<tr class="altColor" id="i70">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestToCircle3D(double%5B%5D,double%5B%5D,double,double%5B%5D)">nearestToCircle3D</a></span>&#8203;(double[]&nbsp;circleCenter,
double[]&nbsp;circleNormal,
double&nbsp;circleRad,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Compute the nearest point of a 3D circle (circumfence, not the inner area) to a given point.</div>
</td>
</tr>
<tr class="rowColor" id="i71">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestToLineSegment(double,double,double,double,double,double)">nearestToLineSegment</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</code></th>
<td class="colLast">
<div class="block">Computes the nearest point of a line segment (p1, p2) to another point q.</div>
</td>
</tr>
<tr class="altColor" id="i72">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nearestToLineSegment3D(double,double,double,double,double,double,double,double,double)">nearestToLineSegment3D</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p1z,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;p2z,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;qz)</code></th>
<td class="colLast">
<div class="block">Computes the nearest point of a line segment (p1, p2) to another point q in 3D.</div>
</td>
</tr>
<tr class="rowColor" id="i73">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#onWhichSide(double,double,double,double,double,double)">onWhichSide</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</code></th>
<td class="colLast">
<div class="block">Decide if q is on the left side, right side of the straight line that goes through (p1, p2), or if it is nearly on the (infinite) straight line.</div>
</td>
</tr>
<tr class="altColor" id="i74">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orderClocksense(double%5B%5D%5B%5D,boolean)">orderClocksense</a></span>&#8203;(double[][]&nbsp;polygon,
boolean&nbsp;counterClockwise)</code></th>
<td class="colLast">
<div class="block">Order a 2D polygon according the given ordering sense.</div>
</td>
</tr>
<tr class="rowColor" id="i75">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#precomputeInsideTriangle2D(double%5B%5D,double%5B%5D,double%5B%5D)">precomputeInsideTriangle2D</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3)</code></th>
<td class="colLast">
<div class="block">Precompute the check, whether a given point is inside a 2D triangle.</div>
</td>
</tr>
<tr class="altColor" id="i76">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#precomputeTriangle2Dscanline(double%5B%5D,double%5B%5D,double%5B%5D)">precomputeTriangle2Dscanline</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3)</code></th>
<td class="colLast">
<div class="block">Precompute the computaton of triangle scanlines.</div>
</td>
</tr>
<tr class="rowColor" id="i77">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#project3Dto3D(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,boolean)">project3Dto3D</a></span>&#8203;(double[]&nbsp;point,
double[]&nbsp;zero,
double[]&nbsp;xAxis,
double[]&nbsp;yAxis,
double[]&nbsp;zAxis,
boolean&nbsp;checkAxis)</code></th>
<td class="colLast">
<div class="block">Given a point in a our 'normal' (xzy) coordinate system.</div>
</td>
</tr>
<tr class="altColor" id="i78">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#project3Dto3Dinv(double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,double%5B%5D,boolean)">project3Dto3Dinv</a></span>&#8203;(double[]&nbsp;point,
double[]&nbsp;zero,
double[]&nbsp;xAxis,
double[]&nbsp;yAxis,
double[]&nbsp;zAxis,
boolean&nbsp;checkAxis)</code></th>
<td class="colLast">
<div class="block">Given a point p' in coordinates according (zero,xAxis,yAxis,zAxis), what are the coordinates in our 'normal' (xzy) coordinate system?</div>
</td>
</tr>
<tr class="rowColor" id="i79">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectOnLine(double,double,double,double,double,double)">projectOnLine</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy)</code></th>
<td class="colLast">
<div class="block">Computes the rectangular projection of q on the straight line p+i&middot;m.</div>
</td>
</tr>
<tr class="altColor" id="i80">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectOnLine3D(double%5B%5D,double%5B%5D,double%5B%5D)">projectOnLine3D</a></span>&#8203;(double[]&nbsp;p,
double[]&nbsp;m,
double[]&nbsp;q)</code></th>
<td class="colLast">
<div class="block">Computes the rectangular projection in 3D of q on the straight line p+i&middot;m.</div>
</td>
</tr>
<tr class="rowColor" id="i81">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectOnLine3D(double,double,double,double,double,double,double,double,double)">projectOnLine3D</a></span>&#8203;(double&nbsp;px,
double&nbsp;py,
double&nbsp;pz,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;mz,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;qz)</code></th>
<td class="colLast">
<div class="block">Computes the rectangular projection in 3D of q on the straight line p+i&middot;m.</div>
</td>
</tr>
<tr class="altColor" id="i82">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectOnLineSegment(double,double,double,double,double,double)">projectOnLineSegment</a></span>&#8203;(double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</code></th>
<td class="colLast">
<div class="block">Computes the rectangular projection of q on a line segment (p1, p2).</div>
</td>
</tr>
<tr class="rowColor" id="i83">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectOnPolygonPoint3D(double%5B%5D%5B%5D,double%5B%5D%5B%5D,double%5B%5D)">projectOnPolygonPoint3D</a></span>&#8203;(double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</code></th>
<td class="colLast">
<div class="block">Project a point to a 3D polygon, whereas the projection direction is the polygon's normal.</div>
</td>
</tr>
<tr class="altColor" id="i84">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectPoint3Dto2D(double%5B%5D,int,int)">projectPoint3Dto2D</a></span>&#8203;(double[]&nbsp;point,
int&nbsp;dimension1,
int&nbsp;dimension2)</code></th>
<td class="colLast">
<div class="block">Copy two dimensions from a point.</div>
</td>
</tr>
<tr class="rowColor" id="i85">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#projectPoints3Dto2D(double%5B%5D%5B%5D,int,int)">projectPoints3Dto2D</a></span>&#8203;(double[][]&nbsp;points,
int&nbsp;dimension1,
int&nbsp;dimension2)</code></th>
<td class="colLast">
<div class="block">Copy two dimensions from a list of points.</div>
</td>
</tr>
<tr class="altColor" id="i86">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduceDensityAngles(basics.util.DoubleArrayList,double)">reduceDensityAngles</a></span>&#8203;(<a href="../util/DoubleArrayList.html" title="class in basics.util">DoubleArrayList</a>&nbsp;angles,
double&nbsp;removeDiff)</code></th>
<td class="colLast">
<div class="block">Reduce the density of an unordered list of angles.</div>
</td>
</tr>
<tr class="rowColor" id="i87">
<td class="colFirst"><code>static double</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reduceRadians(double)">reduceRadians</a></span>&#8203;(double&nbsp;angle)</code></th>
<td class="colLast">
<div class="block">Maps an angle in the range of -5&middot;&pi;...+5&middot;&pi; in the range &plusmn;&pi;.</div>
</td>
</tr>
<tr class="altColor" id="i88">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#relativePose(double,double,double,double,double,double)">relativePose</a></span>&#8203;(double&nbsp;fromX,
double&nbsp;fromY,
double&nbsp;fromAngle,
double&nbsp;toX,
double&nbsp;toY,
double&nbsp;toAngle)</code></th>
<td class="colLast">
<div class="block">Compute the relative pose between two poses.</div>
</td>
</tr>
<tr class="rowColor" id="i89">
<td class="colFirst"><code>static double[][]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#tangentsForTwoCircles(double,double,double,double,double,double)">tangentsForTwoCircles</a></span>&#8203;(double&nbsp;x1,
double&nbsp;y1,
double&nbsp;r1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;r2)</code></th>
<td class="colLast">
<div class="block">Compute the up to 4 tangent for two circles.</div>
</td>
</tr>
<tr class="altColor" id="i90">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#triangle2Dscanline(double%5B%5D,double%5B%5D,double%5B%5D,double)">triangle2Dscanline</a></span>&#8203;(double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Get the scanline minX...maxX that covers a triangle at a given y.</div>
</td>
</tr>
<tr class="rowColor" id="i91">
<td class="colFirst"><code>static double[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#triangle2DscanlinePrecomp(double%5B%5D,double)">triangle2DscanlinePrecomp</a></span>&#8203;(double[]&nbsp;precomp,
double&nbsp;y)</code></th>
<td class="colLast">
<div class="block">Get the scanline minX...maxX that covers a triangle at a given y.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="intersectLinePlane(double[],double[],double[],double[])">intersectLinePlane</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectLinePlane</span>&#8203;(<span class="arguments">double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[]&nbsp;linePoint,
double[]&nbsp;lineDirection)</span></div>
<div class="block">Compute the intersection of line and plane (<a href="https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection">formula</a>).
 The plane is given by a plane point and normal vector.
 The line is given by line point and direction vector.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>planePoint</code> - one point of the plane</dd>
<dd><code>planeNormal</code> - the normal vector of the plane</dd>
<dd><code>linePoint</code> - one point of the line</dd>
<dd><code>lineDirection</code> - the direction of the line</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>intersection array of 2 with [0]: point as array, [1][0] multiplier of the line direction vector to get from the line point to the intersection point; null, line and plane are parallel</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectTwoConvexPolygons3DsamePlane(double[][],double[][],double[][])">intersectTwoConvexPolygons3DsamePlane</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectTwoConvexPolygons3DsamePlane</span>&#8203;(<span class="arguments">double[][]&nbsp;points1,
double[][]&nbsp;points2,
double[][]&nbsp;plane)</span></div>
<div class="block">Compute the intersection polygon from two 3D convex polygons. The 3D polygons must reside in the same plane. Also the intersection is projected into this plane.
 <i>Note: </i>It will not checked, if the input polygons are really convex. If not, the result ist not correct.<br>
 <i>Further note: </i>The operation is performed on a 2D projection. If the input polygons are not in the same plane, the result polygon either is. <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first polygon</dd>
<dd><code>points2</code> - second polygon</dd>
<dd><code>plane</code> - plane of the polygons as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result (convex) intersection polygon or null for no intersection. Note, if the intersection is a point or line, also null will be returned.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insidePolygon3D(double[][],double[][],double[])">insidePolygon3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insidePolygon3D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether a given point is inside a 3D polygon.
 <i>Note:</i> It will not be checked, if the 3D polygon is in a plane. Moreover, it is not checked, if the given point resides on the polygon's plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - polygon &ndash; sequence of 3D points</dd>
<dd><code>plane</code> - plane of first polygon as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dd><code>point</code> - point to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>inside?</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestPlanePoint(double[],double[],double[])">nearestPlanePoint</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">nearestPlanePoint</span>&#8203;(<span class="arguments">double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[]&nbsp;point)</span></div>
<div class="block">Compute the nearest point of the plane to a point.
 We can also consider it as orthogonal projection of a point on a plane in 3D.
 The plane is given by a plane point and normal vector.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>planePoint</code> - one point of the plane</dd>
<dd><code>planeNormal</code> - the normal vector of the plane</dd>
<dd><code>point</code> - the point for which the nearest point should be computed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nearest plane point array of 2 with [0]: point as array, [1][0] multiplier of the plane normal to get from the line point to the intersection point. E.g., if the plane normal points to outside and the point also is outside, this value is &lt;0 as we have to add the negative normal to get to the plane.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectOnPolygonPoint3D(double[][],double[][],double[])">projectOnPolygonPoint3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">projectOnPolygonPoint3D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</span></div>
<div class="block">Project a point to a 3D polygon, whereas the projection direction is the polygon's normal.
 Returns null, if the projection is not inside the polygon.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - polygon &ndash; sequence of 3D points</dd>
<dd><code>plane</code> - plane of the polygon as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dd><code>point</code> - point to find the nearest</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nearest plane point array of 2 with [0]: point as array, [1][0] multiplier of the polygon's normal to get from the line point to the intersection point. E.g., if the polygon normal points to outside and the point also is outside, this value is &lt;0 as we have to add the negative normal to get to the plane.<br>
 Returns null, if the projection is not inside the polygon.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestPolygonPoint3D(double[][],double[][],double[])">nearestPolygonPoint3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">nearestPolygonPoint3D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
double[][]&nbsp;plane,
double[]&nbsp;point)</span></div>
<div class="block">Compute to a given point the nearest point 3D that belongs to the convex polygon or its area. 
 This point is<ul>
 <li>the nearest point in the polygon's plane, if it is inside the polygon or</li>
 <li> the nearest point on one of the polygon's edges, if the nearest plane point is outside the polygon</li>
 </ul>
 <i>Note:</i> It will not be checked, if the polygon is convex. If the polygon is not convex, the returned point may not be the nearest.<br>
 <i>Further note:</i> It will not be checked, if the 3D polygon is in a plane. If not, the result will not be correct.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - polygon &ndash; sequence of 3D points</dd>
<dd><code>plane</code> - plane of the polygon as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dd><code>point</code> - point to find the nearest</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nearest point inside the polygon or on the polygon border, never is null</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestPlanePoint(double[],double[],double[],double[])">nearestPlanePoint</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">nearestPlanePoint</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</span></div>
<div class="block">Compute the nearest point of the plane to a point.
 The plane is given by three plane points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first plane point</dd>
<dd><code>p2</code> - second plane point</dd>
<dd><code>p3</code> - third plane point</dd>
<dd><code>point</code> - the point for which the nearest point should be computed</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nearest plane point array of 2 with [0]: point as array, [1][0] multiplier of the plane normal to get from the line point to the intersection point</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectConvexPolygonPlane(double[],double[],double[][])">intersectConvexPolygonPlane</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectConvexPolygonPlane</span>&#8203;(<span class="arguments">double[]&nbsp;planePoint,
double[]&nbsp;planeNormal,
double[][]&nbsp;points)</span></div>
<div class="block">Compute the intersection of a plane and a convex 3D polygon.<br>
 <i>Note:</i> If the polygon is not convex, still a single intersection line segment is computed, even though the actual intersection would be multiple line segments.<br>
 <i>Further note:</i> It will not be checked, if the 3D polygon is in a plane. If not, the result line segment connects the farthest intersections of polygon lines and the plane.
 The plane is given by a plane point and normal vector.
 The line is given by line point and direction vector.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>planePoint</code> - one point of the plane</dd>
<dd><code>planeNormal</code> - the normal vector of the plane</dd>
<dd><code>points</code> - polygon &ndash; sequence of 3D points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with start and end point of the projected line; null for no intersection</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getPlane(double[][])">getPlane</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">getPlane</span>&#8203;(<span class="arguments">double[][]&nbsp;points)</span></div>
<div class="block">Compute the plane of a 3D polygon. It is not checked, if the polygon really resides on a plane.
 If not, arbitrary two edges are used to compute a normal.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - polygon &ndash; sequence of 3D points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0]: one point of the plane, [1]: the normal vector of the plane</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectTwoConvexPolygons3DdifferentPlanes(double[][],double[][],double[][],double[][])">intersectTwoConvexPolygons3DdifferentPlanes</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectTwoConvexPolygons3DdifferentPlanes</span>&#8203;(<span class="arguments">double[][]&nbsp;points1,
double[][]&nbsp;plane1,
double[][]&nbsp;points2,
double[][]&nbsp;plane2)</span></div>
<div class="block">Compute the intersection two convex 3D polygons.<br>
 <i>Note:</i> If the polygon are not convex, still a single intersection line segment is computed, even though the actual intersection would be multiple line segments.<br>
 <i>Further note:</i> It will not be checked, if the 3D polygons are in their planes. If not, the result line segment connects the farthest intersections of polygons.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first polygon &ndash; sequence of 3D points</dd>
<dd><code>plane1</code> - plane of first polygon as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dd><code>points2</code> - second polygon &ndash; sequence of 3D points</dd>
<dd><code>plane2</code> - plane of second polygon as computed by <a href="#getPlane(double%5B%5D%5B%5D)"><code>getPlane(double[][])</code></a>, may be null, then this method computes the plane on its own</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with start and end point of the projected line; null for no intersection</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="aboveTriangle3D(double[],double[],double[],double[])">aboveTriangle3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">aboveTriangle3D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether a given point is above a 3D triangle.
 'Above' means: from the view of the given point the triangle vertices go counter-clockwise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>point</code> - the point to decide, if above</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if point is above</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="aboveTriangle3D(double[],double[],double[],double[],double)">aboveTriangle3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">aboveTriangle3D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point,
double&nbsp;epsilon)</span></div>
<div class="block">Decide whether a given point is above, below or on a 3D triangle.
 'Above' means: from the view of the given point the triangle vertices go counter-clockwise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>point</code> - the point to decide, if above</dd>
<dd><code>epsilon</code> - factor noted as multiplier of the plane normal, if the ratio |point-nearest-plane-point|/|normal| is below epsilon, then the point is considered to be <i>on</i> the triangle plane</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>1 if point is above, -1 if below, 0 if on the plane</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insideTriangle3D(double[],double[],double[],double[])">insideTriangle3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insideTriangle3D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether a given point is inside a 3D triangle.
 The function is based on Barycentric coordinates.
 If the given point is not in the plane, its rectangular projection on the plane is considered.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>point</code> - the point to decide, if inside</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if point is inside</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insideTriangle2D(double[],double[],double[],double[])">insideTriangle2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insideTriangle2D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether a given point is inside a 2D triangle.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>point</code> - the point to decide, if inside</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if point is inside</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="abTriangle2D(double[],double[],double[],double[])">abTriangle2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">abTriangle2D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double[]&nbsp;point)</span></div>
<div class="block">Compute for a triangle with point p1, p2, p3 and a given point p, the relations a, b where<br>
 p=a&middot;(p2-p1)+b&middot;(p3-p1).<br>
 This method does <i>not</i> check, if a point is inside the triangle, i.e. a&ge;0, b&ge;0, a+b&le;1.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>point</code> - the point to decide, if inside</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0]: a, [1]: b; is null for degenerated triangle</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="precomputeInsideTriangle2D(double[],double[],double[])">precomputeInsideTriangle2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">precomputeInsideTriangle2D</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3)</span></div>
<div class="block">Precompute the check, whether a given point is inside a 2D triangle.
 This is useful, if multiple points are checked against the same triangle with <a href="#insideTriangle2Dprecomp(double%5B%5D,double%5B%5D)"><code>insideTriangle2Dprecomp(double[],double[])</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an internal structure carring every precomputation</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insideTriangle2Dprecomp(double[],double[])">insideTriangle2Dprecomp</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insideTriangle2Dprecomp</span>&#8203;(<span class="arguments">double[]&nbsp;precomp,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether a given point is inside a 2D triangle.
 A precomputation of <a href="#precomputeInsideTriangle2D(double%5B%5D,double%5B%5D,double%5B%5D)"><code>precomputeInsideTriangle2D(double[],double[],double[])</code></a> is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomp</code> - internal structure carring every precomputation</dd>
<dd><code>point</code> - the point to decide, if inside</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if point is inside</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="abTriangle2Dprecomp(double[],double[])">abTriangle2Dprecomp</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">abTriangle2Dprecomp</span>&#8203;(<span class="arguments">double[]&nbsp;precomp,
double[]&nbsp;point)</span></div>
<div class="block">Compute for a triangle with point p1, p2, p3 and a given point p, the relations a, b where<br>
 p=a&middot;(p2-p1)+b&middot;(p3-p1).<br>
 This method does <i>not</i> check, if a point is inside the triangle, i.e. a&ge;0, b&ge;0, a+b&le;1.
 A precomputation of <a href="#precomputeInsideTriangle2D(double%5B%5D,double%5B%5D,double%5B%5D)"><code>precomputeInsideTriangle2D(double[],double[],double[])</code></a> is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomp</code> - internal structure carring every precomputation</dd>
<dd><code>point</code> - the point to decide, if inside</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0]: a, [1]: b; is null for degenerated triangle</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="triangle2Dscanline(double[],double[],double[],double)">triangle2Dscanline</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">triangle2Dscanline</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3,
double&nbsp;y)</span></div>
<div class="block">Get the scanline minX...maxX that covers a triangle at a given y.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dd><code>y</code> - given y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with [0]: minX, [1]: maxX. Returns null, if y is outside the triangle.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="precomputeTriangle2Dscanline(double[],double[],double[])">precomputeTriangle2Dscanline</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">precomputeTriangle2Dscanline</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double[]&nbsp;p2,
double[]&nbsp;p3)</span></div>
<div class="block">Precompute the computaton of triangle scanlines.
 This is useful, if multiple scanlines are retrieved from the same triangle with <a href="#triangle2DscanlinePrecomp(double%5B%5D,double)"><code>triangle2DscanlinePrecomp(double[],double)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - first triangle point</dd>
<dd><code>p2</code> - second triangle point</dd>
<dd><code>p3</code> - third triangle  point</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an internal structure carring every precomputation; even internal, the caller can assume [0] is minY, [1] is maxY of the triangle</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="triangle2DscanlinePrecomp(double[],double)">triangle2DscanlinePrecomp</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">triangle2DscanlinePrecomp</span>&#8203;(<span class="arguments">double[]&nbsp;precomp,
double&nbsp;y)</span></div>
<div class="block">Get the scanline minX...maxX that covers a triangle at a given y.
 A precomputation of <a href="#precomputeTriangle2Dscanline(double%5B%5D,double%5B%5D,double%5B%5D)"><code>precomputeTriangle2Dscanline(double[],double[],double[])</code></a> is used.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomp</code> - internal structure carring every precomputation</dd>
<dd><code>y</code> - given y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with [0]: minX, [1]: maxX of points inside the triangle. Returns null, if y is outside the triangle.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="createRightangledTriangle(double,double,double,double,double)">createRightangledTriangle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">createRightangledTriangle</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;r)</span></div>
<div class="block">Create a right-angled triangle with some conditions:<ul>
 <li>Two of the three points, namely p<sub>1</sub>, p<sub>2</sub> are given.</li>
 <li>The third point s should be computed.</li>
 <li>The distance between s and p<sub>2</sub> is given as r&gt;0.</li>
 <li>The right angle is in s, i.e. between the edges p<sub>1</sub> - s and p<sub>2</sub> - s.</li>
 </ul>
 For r&gt;0 we get zero or two points s that fulfill these conditions.<br>
 We can have another view on the problem. Given a circle around p<sub>2</sub> with r, what
 are the tangents going through p<sub>1</sub>? <br>
 <img src="rightangledtriangle.png" alt="create right-angled triangle" width="30%" height="30%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - first point x</dd>
<dd><code>p1y</code> - first point y</dd>
<dd><code>p2x</code> - second point x</dd>
<dd><code>p2y</code> - second point y</dd>
<dd><code>r</code> - distance between p<sub>2</sub> and s</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with points s, both array of two with x, y. May be null, if there is no such point s.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="angXYangXZtoMapPositions(double[],double[])">angXYangXZtoMapPositions</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">angXYangXZtoMapPositions</span>&#8203;(<span class="arguments">double[]&nbsp;a,
double[]&nbsp;b)</span></div>
<div class="block">Compute the rotation XY (yaw) and XZ (pitch) to map two positions, when the ordering is
 <ul>
  <li>first in the x-y plane</li>
  <li>then in the x-z plane</li>
 </ul> 
 In particular, the rotation YZ (roll) must be 0. The rotation is executed about the zero-point.<br>
 <i>Note</i>: it is not checked, whether the two points have the same distance from the zero-point.<br>
 <i>Further note</i>: there are always two rotations that map source and target points. Both are returned.
 The caller may select one, e.g. those with the least sum of angles.<br>
 If an actual rotation <i>matrix</i> is required, the code may look as follows:<pre>
 double[][] angXYangXZ=Geom.angXYangXZtoMapPositions(a, b);
 int index=... // Select 0 or 1 of the pairs
 double angXY=angXYangXZ[index][0];
 double angXZ=angXYangXZ[index][1];
 double[][] rot=Matrix.rotationMatrix3D(Math.sin(angXY),Math.cos(angXY), 
                                        Math.sin(angXZ),Math.cos(angXZ));
 // Matrix.multiply(rot,a); produces b again
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - source position to rotate</dd>
<dd><code>b</code> - target point to reach when rotating a</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with two rotations, each with [0]: rotation XY (yaw), [1]: rotation XZ (pitch)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="angXYangXZtoMapPositionsReverse(double[],double[])">angXYangXZtoMapPositionsReverse</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">angXYangXZtoMapPositionsReverse</span>&#8203;(<span class="arguments">double[]&nbsp;a,
double[]&nbsp;b)</span></div>
<div class="block">Compute the rotation XY (yaw) and XZ (pitch) to map two positions, when the ordering is
 <ul>
  <li>first in the x-z plane</li>
  <li>then in the x-y plane</li>
 </ul> (note, this is reverse to <a href="#angXYangXZtoMapPositions(double%5B%5D,double%5B%5D)"><code>angXYangXZtoMapPositions(double[],double[])</code></a>.
 In particular, the rotation YZ (roll) must be 0. The rotation is executed about the zero-point.<br>
 <i>Note</i>: it is not checked, whether the two points have the same distance from the zero-point.<br>
 <i>Further note</i>: there are always two rotations that map source and target points. Both are returned.
 The caller may select one, e.g. those with the least sum of angles.<br>
 If an actual rotation <i>matrix</i> is required, the code may look as follows:<pre>
 double[][] angXYangXZ=Geom.angXYangXZtoMapPositionsReverse(a, b);
 int index=... // Select 0 or 1 of the pairs
 double angXY=angXYangXZ[index][0];
 double angXZ=angXYangXZ[index][1];
 double[][] rot=Matrix.rotationMatrix3Dreverse(Math.sin(angXY),Math.cos(angXY), 
                                               Math.sin(angXZ),Math.cos(angXZ));
 // Matrix.multiply(rot,a); produces b again
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - source position to rotate</dd>
<dd><code>b</code> - target point to reach when rotating a</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with two rotations, each with [0]: rotation XY (yaw), [1]: rotation XZ (pitch)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation3D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block"><p>Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). Both point lists must have the same size
 and points of the same index are mapped to each others. The solution is based on Rodrigues parameters (Gibbs vectors) and Cayley transformation. This means,
 an over determined linear equation system is derived from the points lists. Solving this, the angle and translation vector is computed that minimize the root-mean square of the difference of mapped <i>points<sub>1</sub></i> and <i>points<sub>2</sub></i>.</p>
 In more detail: Let<ul>
 <li>p<sub>1</sub>&isin;<i>points<sub>1</sub></i> and p<sub>2</sub>&isin;<i>points<sub>2</sub></i> with the same index;</li>
 <li>R<sub>&theta;u</sub> be the rotation quaternion 3D for &theta;, u<sub>x</sub>, u<sub>y</sub>, u<sub>y</sub></li>
 <li>p<sub>1</sub>'=R<sub>&theta;u</sub>&middot;p<sub>1</sub>+t.</li>
 </ul>
 Then the method
 computes (&theta;, u<sub>x</sub>, u<sub>y</sub>, u<sub>y</sub>, t<sub>x</sub>, t<sub>y</sub>, t<sub>z</sub>) that
 minimized the root mean square of | p<sub>1</sub>'-p<sub>2</sub> |.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 7 with <ul><li>[0]: &theta; (radians, counter-clockwise),</li>
 <li>[1]: ux,</li><li>[2]: uy,</li><li>[3]: uz,</li>
 <li>[4]: tx,</li><li>[5]: ty,</li><li>[6]: tz</li>
 </ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation3D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).
 This variation of <a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3D(ArrayList,ArrayList,ArrayList)</code></a> assumes the same weights for all points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 7 with <ul><li>[0]: &theta; (radians, counter-clockwise),</li>
 <li>[1]: ux,</li><li>[2]: uy,</li><li>[3]: uz,</li>
 <li>[4]: tx,</li><li>[5]: ty,</li><li>[6]: tz</li>
 </ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj3D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).
 Also see <a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3D(ArrayList,ArrayList,ArrayList)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj3D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj3D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block">Computes the roto-translation that best converts points (3D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>).
 Also see <a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3D(ArrayList,ArrayList)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3DignoreZ</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation3DignoreZ</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block"><p>Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 In contrast to <a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3D(ArrayList,ArrayList,ArrayList)</code></a>, only x, y of the points are considered, a 3D rotation is computed, and only a 2D translation.
 The motivation: if points1 is a 3D-tilted Lidar scan and points2 the corresponding 2D points in the obstacle map, then
 this method is able to compute the roto-translation (including sensor tilt angles) to match the scan into the obstacle map.</p>
 In more detail: Let<ul>
 <li>p<sub>1</sub>&isin;<i>points<sub>1</sub></i> and p<sub>2</sub>&isin;<i>points<sub>2</sub></i> 2D with the same index;</li>
 <li>R<sub>&alpha;xy,&alpha;xz,&alpha;yz</sub> be the rotation 3D</li>
 <li>p<sub>1</sub>'=R<sub>&alpha;xy,&alpha;xz,&alpha;yz</sub>&middot;(p<sub>x1</sub>,p<sub>y1</sub>,0)+t.</li>
 </ul>
 Then the method
 computes (&alpha;<sub>xy</sub>, &alpha;<sub>xz</sub>, &alpha;<sub>yz</sub>, t<sub>x</sub>, t<sub>y</sub>) that
 minimized the root mean square of (p<sub>x1</sub>'-p<sub>x2</sub>)<sup>2</sup>+(p<sub>y1</sub>'-p<sub>y2</sub>)<sup>2</sup>.<br>
 <p>Note that for &alpha;<sub>xz</sub> and &alpha;<sub>yz</sub> only absolute values are computed. This is because the different
 signs of these angles would produce the same result concerning x, y.</p>
 Further note that first &alpha;<sub>xz</sub> and &alpha;<sub>yz</sub> are applied (the tilt angles, in 'parallel'), then &alpha;<sub>xy</sub> (orientation angle).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list 2D (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list 2D (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 5 with <ul>
 <li>[0]: &alpha;<sub>xy</sub>,</li><li>[1]: |&alpha;<sub>xz</sub>|,</li><li>[2]: |&alpha;<sub>yz</sub>|,</li>
 <li>[3]: tx,</li><li>[4]: ty</li>
 </ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation3DignoreZ</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation3DignoreZ</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block">Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 This variation of <a href="#getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3DignoreZ(ArrayList,ArrayList,ArrayList)</code></a> assumes the same weights for all points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list 2D (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list 2D (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 5 with <ul>
 <li>[0]: &alpha;<sub>xy</sub>,</li><li>[1]: |&alpha;<sub>xz</sub>|,</li><li>[2]: |&alpha;<sub>yz</sub>|,</li>
 <li>[3]: tx,</li><li>[4]: ty</li>
 </ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3DignoreZ</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj3DignoreZ</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block"><p>Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 Also see <a href="#getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3DignoreZ(ArrayList,ArrayList,ArrayList)</code></a>.</p>
 <i>Important:</i> Roto-translations always convert all three coordinates of a point. However, we expect:
 <ul>
  <li>The point to convert must have z=0,</li>
  <li>We ignore the z coordinate of roto-translated point.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list 2D (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list 2D (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj3DignoreZ(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj3DignoreZ</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj3DignoreZ</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block"><p>Computes the 3D roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 Also see <a href="#getRotoTranslation3DignoreZ(java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3DignoreZ(ArrayList,ArrayList)</code></a>.</p>
 <i>Important:</i> Roto-translations always convert all three coordinates of a point. However, we expect:
 <ul>
  <li>The point to convert must have z=0,</li>
  <li>We ignore the z coordinate of roto-translated point.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list 2D (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list 2D (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslation2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation2D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block"><p>Computes the roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). Both point lists must have the same size
 and points of the same index are mapped to each others. The solution is based on Rodrigues parameters (Gibbs vectors) and Cayley transformation. This means,
 an over determined linear equation system is derived from the points lists. Solving this, the angle and translation vector is computed that minimize the root-mean square of the difference of mapped <i>points<sub>1</sub></i> and <i>points<sub>2</sub></i>.</p>
 In more detail: Let<ul>
 <li>p<sub>1</sub>&isin;<i>points<sub>1</sub></i> and p<sub>2</sub>&isin;<i>points<sub>2</sub></i> with the same index;</li>
 <li>R<sub>&alpha;</sub> be the rotation matrix 2D for &alpha; (e.g. computed using R=Matrix.rotationMatrix2D(Math.sin(alpha), Math.cos(alpha)););</li>
 <li>p<sub>1</sub>'=R<sub>&alpha;</sub>&middot;p<sub>1</sub>+t.</li>
 </ul>
 Then the method
 computes (&alpha;, t<sub>x</sub>, t<sub>y</sub>) that
 minimized the root mean square of | p<sub>1</sub>'-p<sub>2</sub> |.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 3 with <ul><li>[0]: alpha (radians, counter-clockwise),</li><li>[1]: tx,</li><li>[2]: ty</li></ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslation2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getRotoTranslation2D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block">Computes the roto-translation that best converts points (2D) of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 This variation of <a href="#getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation2D(ArrayList,ArrayList,ArrayList)</code></a> assumes the same weights for all points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 3 with <ul><li>[0]: alpha (radians, counter-clockwise),</li><li>[1]: tx,</li><li>[2]: ty</li></ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj2D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2,
java.util.ArrayList&lt;java.lang.Double&gt;&nbsp;weights)</span></div>
<div class="block"><p>Computes the roto-translation that best converts points of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 Also see <a href="#getRotoTranslation2D(java.util.ArrayList,java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation2D(ArrayList,ArrayList,ArrayList)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dd><code>weights</code> - list of weights that indicate, how the pair of points influences the result, list may be null</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getRotoTranslationObj2D(java.util.ArrayList,java.util.ArrayList)">getRotoTranslationObj2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType"><a href="rot/RotoTranslation.html" title="class in basics.math.rot">RotoTranslation</a></span>&nbsp;<span class="memberName">getRotoTranslationObj2D</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points1,
java.util.ArrayList&lt;double[]&gt;&nbsp;points2)</span></div>
<div class="block"><p>Computes the roto-translation that best converts points of the first list (<i>points<sub>1</sub></i>) to points of the second (<i>points<sub>2</sub></i>). 
 Also see <a href="#getRotoTranslation3D(java.util.ArrayList,java.util.ArrayList)"><code>getRotoTranslation3D(ArrayList,ArrayList)</code></a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first points list (list of points that should undergo rotation and translation)</dd>
<dd><code>points2</code> - second points list (list of points that should be targeted)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>roto-translation to map first points to second points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getMBR(double[][])">getMBR</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getMBR</span>&#8203;(<span class="arguments">double[][]&nbsp;points)</span></div>
<div class="block">Get the minimal bounding rect of all points in the list.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - array of points, each array of 2 [0]: x, [1]: y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: minX,</li><li>[1]: minY,</li><li>[2]: maxX,</li><li>[3]: maxY;</li></ul> is null, if no point is in the list</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getMBR(java.util.ArrayList)">getMBR</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getMBR</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points)</span></div>
<div class="block">Get the minimal bounding rect of all points in the list.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - list of points, each array of 2 [0]: x, [1]: y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: minX,</li><li>[1]: minY,</li><li>[2]: maxX,</li><li>[3]: maxY;</li></ul> is null, if no point is in the list</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="joinMBRs(double[],double[])">joinMBRs</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">joinMBRs</span>&#8203;(<span class="arguments">double[]&nbsp;mbr1,
double[]&nbsp;mbr2)</span></div>
<div class="block">Computes two bounding rects to a new bounding rect; also may take null bounding rects.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mbr1</code> - first bounding rect</dd>
<dd><code>mbr2</code> - second bounding rect</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: minX,</li><li>[1]: minY,</li><li>[2]: maxX,</li><li>[3]: maxY;</li></ul> is null, both input MBRs are null</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getMBC(double[][])">getMBC</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getMBC</span>&#8203;(<span class="arguments">double[][]&nbsp;points)</span></div>
<div class="block">Get the minimal bounding cubic of all points in the list.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - array of points, each array of 3 [0]: x, [1]: y, [2]: z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 6 with <ul><li>[0]: minX,</li><li>[1]: minY,</li><li>[2]: minZ,</li><li>[3]: maxX,</li><li>[4]: maxY,</li><li>[5]: maxZ;</li></ul> is null, if no point is in the list</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getMBC(java.util.ArrayList)">getMBC</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">getMBC</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points)</span></div>
<div class="block">Get the minimal bounding cubic of all points in the list.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - array of points, each array of 3 [0]: x, [1]: y, [2]: z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 6 with <ul><li>[0]: minX,</li><li>[1]: minY,</li><li>[2]: minZ,</li><li>[3]: maxX,</li><li>[4]: maxY,</li><li>[5]: maxZ;</li></ul> is null, if no point is in the list</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="convexHull2D(double[][])">convexHull2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">convexHull2D</span>&#8203;(<span class="arguments">double[][]&nbsp;points)</span></div>
<div class="block">Compute a convex hull of 2D points using <i>Andrew's monotone chain convex hull algorithm</i>.
 We can distinguish three cases:<ul>
 <li>If the point list is empty, den convex hull is an empty array.</li>
 <li>If the point list contains a one point or two points, then the convex hull equals the input.</li>
 <li>Otherwise, the convex hull is computed. For this, the list of points is sorted, in particular modified.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - 2D points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>convex hull that goes counter-clockwise</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="cutLines(double,double,double,double,double,double,double,double)">cutLines</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">cutLines</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny)</span></div>
<div class="block">Computes the intersection of two straight lines p+i&middot;m and q+j&middot;n. The lines are considered as infinite, i.e. i,j&isin;]-&infin;,&infin;[.
 Returns not the intersection s but the multiples i, j of m, n to reach s, i.e.
 p+i&middot;m=q+j&middot;n = s.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - first line's start point x</dd>
<dd><code>py</code> - first line's start point y</dd>
<dd><code>mx</code> - first line's vector x</dd>
<dd><code>my</code> - first line's vector y</dd>
<dd><code>qx</code> - second line's start point x</dd>
<dd><code>qy</code> - second line's start point y</dd>
<dd><code>nx</code> - second line's vector x</dd>
<dd><code>ny</code> - second line's vector y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2; [0]: i, [1]: j; null, if the lines are parallel</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="cutHorizontalSweepLine(double,double,double,double,double,double)">cutHorizontalSweepLine</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">cutHorizontalSweepLine</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny)</span></div>
<div class="block">Computes the intersection of the horizontal sweep line p+i&middot;(1,0) and straight line q+j&middot;n. The lines are considered as infinite, i.e. i,j&isin;]-&infin;,&infin;[.
 Returns not the intersection s but the multiples i, j of m, n to reach s, i.e.
 p+i&middot;m=q+j&middot;n = s.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - first line's start point x</dd>
<dd><code>py</code> - first line's start point y</dd>
<dd><code>qx</code> - second line's start point x</dd>
<dd><code>qy</code> - second line's start point y</dd>
<dd><code>nx</code> - second line's vector x</dd>
<dd><code>ny</code> - second line's vector y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2; [0]: i, [1]: j; null, if the lines are parallel</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="cutLineSegments(double,double,double,double,double,double,double,double)">cutLineSegments</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">cutLineSegments</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;q1x,
double&nbsp;q1y,
double&nbsp;q2x,
double&nbsp;q2y)</span></div>
<div class="block">Computes the intersection of two line segments (p1,p2) and (q1,q2). The result is 0 or 1 intersection point.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - first line first point x</dd>
<dd><code>p1y</code> - first line first point y</dd>
<dd><code>p2x</code> - first line second point x</dd>
<dd><code>p2y</code> - first line second  point y</dd>
<dd><code>q1x</code> - second line first point x</dd>
<dd><code>q1y</code> - second line first point y</dd>
<dd><code>q2x</code> - second line second point x</dd>
<dd><code>q2y</code> - second line second  point y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with [0] intersection point x, [1] intersection point y, [2] portion of intersection p1-p2 (0...1), [3] portion of intersection q1-q2 (0...1). Maybe null for no intersection</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectOnLine(double,double,double,double,double,double)">projectOnLine</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">projectOnLine</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy)</span></div>
<div class="block"><p>Computes the rectangular projection of q on the straight line p+i&middot;m. The line is considered as infinite, i.e. i&isin;]-&infin;,&infin;[.</p>
 <img src="projectonline.png" alt="project point to line" width="40%" height="40%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - line's start point x</dd>
<dd><code>py</code> - line's start point y</dd>
<dd><code>mx</code> - line's vector x</dd>
<dd><code>my</code> - line's vector y</dd>
<dd><code>qx</code> - point to project x</dd>
<dd><code>qy</code> - point to project y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: projection x,</li><li>[1]: projection y,</li><li>[2]: value of i;</li></ul> null, if m is too small</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectOnLine3D(double,double,double,double,double,double,double,double,double)">projectOnLine3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">projectOnLine3D</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;pz,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;mz,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;qz)</span></div>
<div class="block">Computes the rectangular projection in 3D of q on the straight line p+i&middot;m. The line is considered as infinite, i.e. i&isin;]-&infin;,&infin;[.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - line's start point x</dd>
<dd><code>py</code> - line's start point y</dd>
<dd><code>pz</code> - line's start point z</dd>
<dd><code>mx</code> - line's vector x</dd>
<dd><code>my</code> - line's vector y</dd>
<dd><code>mz</code> - line's vector z</dd>
<dd><code>qx</code> - point to project x</dd>
<dd><code>qy</code> - point to project y</dd>
<dd><code>qz</code> - point to project z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: projection x,</li><li>[1]: projection y,</li><li>[2]: projection z,</li><li>[3]: value of i;</li></ul> null, if m is too small</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectOnLine3D(double[],double[],double[])">projectOnLine3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">projectOnLine3D</span>&#8203;(<span class="arguments">double[]&nbsp;p,
double[]&nbsp;m,
double[]&nbsp;q)</span></div>
<div class="block">Computes the rectangular projection in 3D of q on the straight line p+i&middot;m. The line is considered as infinite, i.e. i&isin;]-&infin;,&infin;[.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p</code> - line's start point x,y,z</dd>
<dd><code>m</code> - line's vector x,yz</dd>
<dd><code>q</code> - point to project x,yz</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 4 with <ul><li>[0]: projection x,</li><li>[1]: projection y,</li><li>[2]: projection z,</li><li>[3]: value of i;</li></ul> null, if m is too small</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="onWhichSide(double,double,double,double,double,double)">onWhichSide</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int</span>&nbsp;<span class="memberName">onWhichSide</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</span></div>
<div class="block"><p>Decide if q is on the left side, right side of the straight line that goes through (p1, p2), or if it is nearly on the (infinite) straight line.
 The side assumes a viewing direction from p1 to p2.</p>
 <i>Note</i>: this method does not perform a check, whether p1 equals p2. In this case: the result is 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - line segment's start point x</dd>
<dd><code>p1y</code> - line segment's start point y</dd>
<dd><code>p2x</code> - line segment's end point x</dd>
<dd><code>p2y</code> - line segment's end point y</dd>
<dd><code>qx</code> - point to check the side x</dd>
<dd><code>qy</code> - point to check the side y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>-1: left side, 1: right side, 0: nearly on the line</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectOnLineSegment(double,double,double,double,double,double)">projectOnLineSegment</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">projectOnLineSegment</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</span></div>
<div class="block"><p>Computes the rectangular projection of q on a line segment (p1, p2).</p>
 <img src="projectonlinesegment.png" alt="project point to line segment" width="40%" height="40%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - line segment's start point x</dd>
<dd><code>p1y</code> - line segment's start point y</dd>
<dd><code>p2x</code> - line segment's end point x</dd>
<dd><code>p2y</code> - line segment's end point y</dd>
<dd><code>qx</code> - point to which the projection is computed x</dd>
<dd><code>qy</code> - point to which the projection is computed y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0]: projection x, [1]: projection y; null, if p1, p2 are too close or if the projection is outside the segment between p1 and p2</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestToLineSegment(double,double,double,double,double,double)">nearestToLineSegment</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">nearestToLineSegment</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;qx,
double&nbsp;qy)</span></div>
<div class="block"><p>Computes the nearest point of a line segment (p1, p2) to another point q.
 The nearest point is the rectangular projection on the line segment, if the projection is on the segment, or either p1 or p2.</p>
 <p>Note: if the line segment (p1, p2) is very small, the nearest point of {p1, p2} is returned.</p>
 <img src="nearesttolinesegment.png" alt="project point to line segment" width="40%" height="40%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - line segment's start point x</dd>
<dd><code>p1y</code> - line segment's start point y</dd>
<dd><code>p2x</code> - line segment's end point x</dd>
<dd><code>p2y</code> - line segment's end point y</dd>
<dd><code>qx</code> - point to which the nearest is computed x</dd>
<dd><code>qy</code> - point to which the nearest is computed y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0]: nearest point x, [1]: nearest point y (can never be null)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestToLineSegment3D(double,double,double,double,double,double,double,double,double)">nearestToLineSegment3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">nearestToLineSegment3D</span>&#8203;(<span class="arguments">double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p1z,
double&nbsp;p2x,
double&nbsp;p2y,
double&nbsp;p2z,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;qz)</span></div>
<div class="block"><p>Computes the nearest point of a line segment (p1, p2) to another point q in 3D.
 The nearest point is the rectangular projection on the line segment, if the projection is on the segment, or either p1 or p2.</p>
 <p>Note: if the line segment (p1, p2) is very small, the nearest point of {p1, p2} is returned.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1x</code> - line segment's start point x</dd>
<dd><code>p1y</code> - line segment's start point y</dd>
<dd><code>p1z</code> - line segment's start point z</dd>
<dd><code>p2x</code> - line segment's end point x</dd>
<dd><code>p2y</code> - line segment's end point y</dd>
<dd><code>p2z</code> - line segment's end point z</dd>
<dd><code>qx</code> - point to which the nearest is computed x</dd>
<dd><code>qy</code> - point to which the nearest is computed y</dd>
<dd><code>qz</code> - point to which the nearest is computed z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 3 with [0]: nearest point x, [1]: nearest point y, [2]: nearest point z (can never be null)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="circleCenterFromThreePoints(double,double,double,double,double,double)">circleCenterFromThreePoints</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">circleCenterFromThreePoints</span>&#8203;(<span class="arguments">double&nbsp;x1,
double&nbsp;y1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;x3,
double&nbsp;y3)</span></div>
<div class="block">Computes a circle center by three points that reside on this circle.
 For any three points that are not on a straight line, there is only one such circle.
 A RuntimeExeption is issued, if the three points reside on a line.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - point 1 x</dd>
<dd><code>y1</code> - point 1 y</dd>
<dd><code>x2</code> - point 2 x</dd>
<dd><code>y2</code> - point 2 y</dd>
<dd><code>x3</code> - point 3 x</dd>
<dd><code>y3</code> - point 3 y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>double[2] with [0]: x, [1]: y</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectLineCircle(double,double,double,double,double,double,double)">intersectLineCircle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectLineCircle</span>&#8203;(<span class="arguments">double&nbsp;cx,
double&nbsp;cy,
double&nbsp;rad,
double&nbsp;p1x,
double&nbsp;p1y,
double&nbsp;p2x,
double&nbsp;p2y)</span></div>
<div class="block">Intersects an infinite line with a circle. The result is 0, 1, or 2 intersection points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cx</code> - circle center x</dd>
<dd><code>cy</code> - circle center y</dd>
<dd><code>rad</code> - circle radius</dd>
<dd><code>p1x</code> - line point 1 x</dd>
<dd><code>p1y</code> - line point 1 y</dd>
<dd><code>p2x</code> - line point 2 x</dd>
<dd><code>p2y</code> - line point 2 y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 0, 1, or 2 with intersection point(s), each array of 3: [0]: x, [1]: y, [2]: portion between point 1 and point 2 (i.e. 0.0 means point 1, 1.0 means point 2)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectionRatioLineCircle(double,double,double,double,double,double,double)">intersectionRatioLineCircle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">intersectionRatioLineCircle</span>&#8203;(<span class="arguments">double&nbsp;cx,
double&nbsp;cy,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;dx,
double&nbsp;dy)</span></div>
<div class="block">Intersects an infinite line with a circle. The result is 0, 2 intersections, given as ratios of the straight line vector.<br>
 The straight line is given as p+q&middot;d with variable q. The intersection is given as {q<sub>1</sub>, q<sub>2</sub>} where<br>
 |p + q<sub>i</sub>&middot;d - c|=r</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cx</code> - circle center x</dd>
<dd><code>cy</code> - circle center y</dd>
<dd><code>r</code> - circle radius</dd>
<dd><code>px</code> - line point x</dd>
<dd><code>py</code> - line point y</dd>
<dd><code>dx</code> - line vector x</dd>
<dd><code>dy</code> - line vector y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with intersection ratios [q<sub>1</sub>,q<sub>2</sub>], whereas q<sub>1</sub> is the larger ratio. Also returns two elements if q<sub>1</sub>=q<sub>2</sub>. Returns null, if there is no intersection.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectTwoCircles(double,double,double,double,double,double)">intersectTwoCircles</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectTwoCircles</span>&#8203;(<span class="arguments">double&nbsp;x1,
double&nbsp;y1,
double&nbsp;r1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;r2)</span></div>
<div class="block">Intersects two circles. We have three cases:
 <ul>
 <li> They intersect in two points. Then, both points are returned. The first point is the intersection that appears on the right side of the line between first and second circle center. The second is the one on the left.</li>
 <li> They intersect in one point. Then, two times the same point is returned.</li>
 <li> They do not intersect. Then, null is returned.</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - first circle's center x</dd>
<dd><code>y1</code> - first circle's center y</dd>
<dd><code>r1</code> - first circle's radius</dd>
<dd><code>x2</code> - second circle's center x</dd>
<dd><code>y2</code> - second circle's center y</dd>
<dd><code>r2</code> - second circle's radius</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of two, each x, y; or null if the circles do not intersect</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectCircleSphere(double[],double[],double,double[],double)">intersectCircleSphere</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectCircleSphere</span>&#8203;(<span class="arguments">double[]&nbsp;cc,
double[]&nbsp;nc,
double&nbsp;rc,
double[]&nbsp;cs,
double&nbsp;rs)</span></div>
<div class="block">Intersect a 3D circle with a sphere. The result is either zero or two intersection points (even, if the two points are identical).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cc</code> - circle center</dd>
<dd><code>nc</code> - circle plane normal</dd>
<dd><code>rc</code> - circle radius</dd>
<dd><code>cs</code> - sphere center</dd>
<dd><code>rs</code> - circle radius</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 0 or 2 with the intersection points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectTwoSpheres(double[],double,double[],double)">intersectTwoSpheres</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">intersectTwoSpheres</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double&nbsp;rad1,
double[]&nbsp;p2,
double&nbsp;rad2)</span></div>
<div class="block">Intersect two spheres. The result is either empty or a circle; if the two spheres touch, a circle with zero radius is returned.
 The result circle in 3D is represented by center (x, y, z), radius r and the unity normal vector of the circle plane.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - sphere center 1</dd>
<dd><code>rad1</code> - sphere radius 1</dd>
<dd><code>p2</code> - sphere center 2</dd>
<dd><code>rad2</code> - sphere radius 2</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 7 with [0]: center x, [1]: center y, [2]: center z, [3] normal x, [4] normal y, [5] normal z, [6]: r; is null for no intesection</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectThreeSpheres(double[],double,double[],double,double[],double)">intersectThreeSpheres</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectThreeSpheres</span>&#8203;(<span class="arguments">double[]&nbsp;p1,
double&nbsp;rad1,
double[]&nbsp;p2,
double&nbsp;rad2,
double[]&nbsp;p3,
double&nbsp;rad3)</span></div>
<div class="block">Intersect three spheres. The result is either zero or two intersection points (even, if the two points are identical).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p1</code> - sphere center 1</dd>
<dd><code>rad1</code> - sphere radius 1</dd>
<dd><code>p2</code> - sphere center 2</dd>
<dd><code>rad2</code> - sphere radius 2</dd>
<dd><code>p3</code> - sphere center 3</dd>
<dd><code>rad3</code> - sphere radius 3</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 0 or 2 with the intersection points</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectionRatioLineSphere(double,double,double,double,double,double,double,double,double,double)">intersectionRatioLineSphere</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">intersectionRatioLineSphere</span>&#8203;(<span class="arguments">double&nbsp;cx,
double&nbsp;cy,
double&nbsp;cz,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;pz,
double&nbsp;dx,
double&nbsp;dy,
double&nbsp;dz)</span></div>
<div class="block">Intersects an infinite line with a sphere. The result is 0, 2 intersections, given as ratios of the straight line vector.<br>
 The straight line is given as p+q&middot;d with variable q. The intersection is given as {q<sub>1</sub>, q<sub>2</sub>} where<br>
 |p + q<sub>i</sub>&middot;d - c|=r</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cx</code> - sphere center x</dd>
<dd><code>cy</code> - sphere center y</dd>
<dd><code>cz</code> - sphere center z</dd>
<dd><code>r</code> - sphere radius</dd>
<dd><code>px</code> - line point x</dd>
<dd><code>py</code> - line point y</dd>
<dd><code>pz</code> - line point z</dd>
<dd><code>dx</code> - line vector x</dd>
<dd><code>dy</code> - line vector y</dd>
<dd><code>dz</code> - line vector z</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two with intersection ratios [q<sub>1</sub>,q<sub>2</sub>], whereas q<sub>1</sub> is the larger ratio. Also returns two elements if q<sub>1</sub>=q<sub>2</sub>. Returns null, if there is no intersection.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectSpherePlane(double[],double,double[],double[])">intersectSpherePlane</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectSpherePlane</span>&#8203;(<span class="arguments">double[]&nbsp;sphereCenter,
double&nbsp;sphereRad,
double[]&nbsp;planePoint,
double[]&nbsp;planeNormal)</span></div>
<div class="block">Intersect a sphere with a plane. The result is either a 3D circle or empty.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sphereCenter</code> - sphere center</dd>
<dd><code>sphereRad</code> - sphere radius</dd>
<dd><code>planePoint</code> - one point of the plane</dd>
<dd><code>planeNormal</code> - the normal vector of the plane</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>3D circle [0]: circle center, [1][0]: circle rad, the circle normal is the given plane normal; maybe null for empty intersection</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="nearestToCircle3D(double[],double[],double,double[])">nearestToCircle3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">nearestToCircle3D</span>&#8203;(<span class="arguments">double[]&nbsp;circleCenter,
double[]&nbsp;circleNormal,
double&nbsp;circleRad,
double[]&nbsp;point)</span></div>
<div class="block">Compute the nearest point of a 3D circle (circumfence, not the inner area) to a given point.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>circleCenter</code> - 3D circle center</dd>
<dd><code>circleNormal</code> - 3D circle normal</dd>
<dd><code>circleRad</code> - 3D circle radius</dd>
<dd><code>point</code> - point to look for the nearest point</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>nearest point, never is null</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="tangentsForTwoCircles(double,double,double,double,double,double)">tangentsForTwoCircles</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">tangentsForTwoCircles</span>&#8203;(<span class="arguments">double&nbsp;x1,
double&nbsp;y1,
double&nbsp;r1,
double&nbsp;x2,
double&nbsp;y2,
double&nbsp;r2)</span></div>
<div class="block">Compute the up to 4 tangent for two circles. For each tangent, the respective positions on each circle are returned.
 We have three cases:<ul>
 <li>|(x1,y1)-(x2,y2)|&le;|r1-r2|: we have no tangents at all</li>
 <li>|(x1,y1)-(x2,y2)|&le;r1+r2: we have two tangents, one that is completely right one left of the centers</li>
 <li>otherwise: we have four tangents, two right and left and two that crosses the connection of centers</li>
 </ul>
 <br>
 <img src="tangentsfortwocircles.png" alt="tangent for two circles" width="30%" height="30%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x1</code> - first circle's center x</dd>
<dd><code>y1</code> - first circle's center y</dd>
<dd><code>r1</code> - first circle's radius</dd>
<dd><code>x2</code> - second circle's center x</dd>
<dd><code>y2</code> - second circle's center y</dd>
<dd><code>r2</code> - second circle's radius</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of tangents with 0, 2 or 4 elements; 
 if we have 4 tangents, first, the two that are completely right and left are returned in [0],[1], whereas [2], [3] contain the crossing tangents;
 never returns null, even if there are no tangents;
 each element is an array of 4 with [0],[1]: tangent position on the first circle, [2],[3]: tangent position on the second circle;</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="circlesForTwoTangents(double,double,double,double,double,double,double,double,double)">circlesForTwoTangents</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">circlesForTwoTangents</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;qx,
double&nbsp;qy,
double&nbsp;nx,
double&nbsp;ny,
double&nbsp;r)</span></div>
<div class="block">Given two straight lines p+i&middot;m and q+j&middot;n and radius r.
 Compute the centers of the four circles that have these lines as tangents.<br>
 Note if the lines are parallel, null is returned.<br>
 Each circle either is right or left (denoted as index r or l) in line direction n or m, e.g. c<sub>rl</sub>
 is the circle that is right of the first straight line and left of the second straight line.
 <br>
 <img src="circlesrortwotangents.png" alt="circles for two tangent" width="30%" height="30%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - first line's start point x</dd>
<dd><code>py</code> - first line's start point y</dd>
<dd><code>mx</code> - first line's vector x</dd>
<dd><code>my</code> - first line's vector y</dd>
<dd><code>qx</code> - second line's start point x</dd>
<dd><code>qy</code> - second line's start point y</dd>
<dd><code>nx</code> - second line's vector x</dd>
<dd><code>ny</code> - second line's vector y</dd>
<dd><code>r</code> - circle radius</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of four circles {c<sub>rr</sub>, c<sub>rl</sub>, c<sub>lr</sub>, c<sub>ll</sub>}, each circle center x, y; null if lines are parallel</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="circlesForTangentAndCircle(double,double,double,double,double,double,double,double)">circlesForTangentAndCircle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">circlesForTangentAndCircle</span>&#8203;(<span class="arguments">double&nbsp;px,
double&nbsp;py,
double&nbsp;mx,
double&nbsp;my,
double&nbsp;cxcircle,
double&nbsp;cycircle,
double&nbsp;rcircle,
double&nbsp;r)</span></div>
<div class="block">Given a straight line p+i&middot;m and circle c<sub>xcircle</sub>, c<sub>ycircle</sub> with radius r<sub>circle</sub>, 
 further a radius r for result circles.
 Compute the centers of the four circles that have the line as tangent and touch the given circle.<br>
 Each circle either is right or left (denoted as index r or l) in line direction m.
 Furthermore, each circle either is in front or back (denoted as index front or back) of the given circle in line direction m.
 E.g. c<sub>rback</sub> is on the right side of the tangent and behind the given circle.
 Note that we have three cases:<ul>
 <li>c<sub>xcircle</sub>, c<sub>ycircle</sub> is farer than r+r<sub>circle</sub> from the line: we have no result circle;</li>
 <li>c<sub>xcircle</sub>, c<sub>ycircle</sub> has distance between r<sub>circle</sub> and r+r<sub>circle</sub>: we get two result circles, both either left or right of the line;</li>
 <li>c<sub>xcircle</sub>, c<sub>ycircle</sub> has distance closer than r<sub>circle</sub>: we get four result circles.</li>
 </ul>
 Note that the result array always has four entries in either case.
 <br><br>
 <img src="circlesforangentandcircle.png" alt="circles for tangent and circle" width="50%" height="50%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>px</code> - line's start point x</dd>
<dd><code>py</code> - line's start point y</dd>
<dd><code>mx</code> - line's vector x</dd>
<dd><code>my</code> - line's vector y</dd>
<dd><code>cxcircle</code> - given circle center x</dd>
<dd><code>cycircle</code> - given circle center y</dd>
<dd><code>rcircle</code> - given circle radius</dd>
<dd><code>r</code> - circle radius of result circles</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of four circles {c<sub>rfront</sub>, c<sub>rback</sub>, c<sub>lfront</sub>, c<sub>lback</sub>}, each array of four with circle center (x, y), radius vector from center to line (rx, ry) 
 entry is null if the respective circle does not exist; 
 entire array is never null</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="circleForTangentPointAndCircle(double,double,double,double,double,double,double)">circleForTangentPointAndCircle</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">circleForTangentPointAndCircle</span>&#8203;(<span class="arguments">double&nbsp;cx,
double&nbsp;cy,
double&nbsp;r,
double&nbsp;px,
double&nbsp;py,
double&nbsp;tx,
double&nbsp;ty)</span></div>
<div class="block">Given a circle with center c and radius r; further a point p and tangent vector t.
 Compute the up to two circles that touch the circle and p, futher have the tangent vector t in this point.<br><br>
 <img src="circlefortangentpointandcircle.png" alt="circle for tangent point and circle" width="20%" height="20%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cx</code> - given circle center x</dd>
<dd><code>cy</code> - given circle center y</dd>
<dd><code>r</code> - given circle radius</dd>
<dd><code>px</code> - tangent point x</dd>
<dd><code>py</code> - tangent point y</dd>
<dd><code>tx</code> - tangent vector x</dd>
<dd><code>ty</code> - tangent vector y</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array or 0, 1 or 2 each array of 5 with x, y, r of result circle, ux, uy the touching point of the two circles</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectPoint3Dto2D(double[],int,int)">projectPoint3Dto2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">projectPoint3Dto2D</span>&#8203;(<span class="arguments">double[]&nbsp;point,
int&nbsp;dimension1,
int&nbsp;dimension2)</span></div>
<div class="block">Copy two dimensions from a point.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - point</dd>
<dd><code>dimension1</code> - index of the first dimension to copy, e.g. 0 for x</dd>
<dd><code>dimension2</code> - index of the second dimension to copy, e.g. 0 for x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>point with two dimensions</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="projectPoints3Dto2D(double[][],int,int)">projectPoints3Dto2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">projectPoints3Dto2D</span>&#8203;(<span class="arguments">double[][]&nbsp;points,
int&nbsp;dimension1,
int&nbsp;dimension2)</span></div>
<div class="block">Copy two dimensions from a list of points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - points</dd>
<dd><code>dimension1</code> - index of the first dimension to copy, e.g. 0 for x</dd>
<dd><code>dimension2</code> - index of the second dimension to copy, e.g. 0 for x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>points with two dimensions</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectConvexPolygons2D(double[][],double[][])">intersectConvexPolygons2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectConvexPolygons2D</span>&#8203;(<span class="arguments">double[][]&nbsp;points1,
double[][]&nbsp;points2)</span></div>
<div class="block">Compute the intersection polygon from two convex 2D polygons. Only two dimensions are considered, even though the passed geometries have more dimensions.<br>
 <i>Note: </i>It will not checked, if the input polygons are really convex. If not, the result ist not correct.<br>
 <i>Further note: </i>The operation is performed on a 2D projection. If the input polygons are not in the same plane, the result polygon either is. <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first polygon</dd>
<dd><code>points2</code> - second polygon</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result (convex) intersection polygon or null for no intersection. Note, if the intersection is a point or line, also null will be returned.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="intersectConvexPolygons2D(double[][],double[][],int,int)">intersectConvexPolygons2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">intersectConvexPolygons2D</span>&#8203;(<span class="arguments">double[][]&nbsp;points1,
double[][]&nbsp;points2,
int&nbsp;dimension1,
int&nbsp;dimension2)</span></div>
<div class="block">Compute the intersection polygon from two convex 2D polygons.<br>
 The caller can decide the coordinates that should be taken into account.<br>
 <i>Note: </i>It will not checked, if the input polygons are really convex. If not, the result ist not correct.<br>
 <i>Further note: </i>The operation is performed on a 2D projection. If the input polygons are not in the same plane, the result polygon either is. <br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points1</code> - first polygon</dd>
<dd><code>points2</code> - second polygon</dd>
<dd><code>dimension1</code> - index of the first dimension to check, e.g. 0 for x</dd>
<dd><code>dimension2</code> - index of the second dimension to check, e.g. 0 for x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>result (convex) intersection polygon or null for no intersection. Note, if the intersection is a point or line, also null will be returned.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="createConvexPolygon(java.util.ArrayList,int,int)">createConvexPolygon</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">createConvexPolygon</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points,
int&nbsp;dimension1,
int&nbsp;dimension2)</span></div>
<div class="block">Create a convex polygon from a list of unsorted points (that belong to a convex polygon).<br>
 <i>Important: </i> this method does not execute a convex-hull approach to remove 'inner' points.<br>
 The approach requires the definition of two dimensions. In the respective projection plane, the points are sorted counter-clockwise
 viewed from the center of gravity.<br>
 <i>Note: </i> this method also removes subsequent nearby points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - unsorted points</dd>
<dd><code>dimension1</code> - index of the first dimension to create a projection plane, e.g. 0 for x</dd>
<dd><code>dimension2</code> - index of the second dimension to create a projection plane, e.g. 0 for x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>convex polygon</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insidePolygon2D(double[][],double[])">insidePolygon2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insidePolygon2D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
double[]&nbsp;point)</span></div>
<div class="block">Decide whether the given point is inside the 2D polygon. Only two dimensions are considered, even though the passed geometries have more dimensions.<br>
 <i>Note: </i> This method does not perform a quick bounding box test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - list of polygon points, only the first two dimensions are considered</dd>
<dd><code>point</code> - point to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>inside?</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="insidePolygon2D(double[][],double[],int,int)">insidePolygon2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">insidePolygon2D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
double[]&nbsp;point,
int&nbsp;dimension1,
int&nbsp;dimension2)</span></div>
<div class="block">Decide whether the given point is inside the 2D polygon. Only two dimensions are considered, even though the passed geometries have more dimensions.
 The caller can decide the coordinates that should be taken into account.<br>
 <i>Note: </i> This method does not perform a quick bounding box test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - list of polygon points, only the given two dimensions are considered</dd>
<dd><code>point</code> - point to check</dd>
<dd><code>dimension1</code> - index of the first dimension to check, e.g. 0 for x</dd>
<dd><code>dimension2</code> - index of the second dimension to check, e.g. 0 for x</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>inside?</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="areaSize2D(double[][])">areaSize2D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">areaSize2D</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon)</span></div>
<div class="block">Compute the area size of the ground projected polygon.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - list of polygon points, only the first two dimensions are considered</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>absolute area size</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="areaSize2Dsigned(double[][])">areaSize2Dsigned</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">areaSize2Dsigned</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon)</span></div>
<div class="block">Compute the area size of the ground projected polygon.
 The area size is signed:<ul>
 <li>positive: polygon points go clockwise</li>
 <li>negative: polygon points go counter clockwise</li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - list of polygon points, only the first two dimensions are considered</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>signed area size</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="isConvex(double[][])">isConvex</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">boolean</span>&nbsp;<span class="memberName">isConvex</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon)</span></div>
<div class="block">Decide whether the ground projected polygon is convex.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - list of polygon points, only the first two dimensions are considered</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if convex</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="orderClocksense(double[][],boolean)">orderClocksense</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[][]</span>&nbsp;<span class="memberName">orderClocksense</span>&#8203;(<span class="arguments">double[][]&nbsp;polygon,
boolean&nbsp;counterClockwise)</span></div>
<div class="block">Order a 2D polygon according the given ordering sense.
 If the polygon is alread ordered as wantet, the given polygon is returned (without copying).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>polygon</code> - polygon</dd>
<dd><code>counterClockwise</code> - true: order the polygon counter-clockwise, false, order the polygon clockwise</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>polygon with counter-clockwise ordering (if counterClockwise==true), clockwise otherwise (if counterClockwise==false)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="diffRadians(double,double)">diffRadians</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">diffRadians</span>&#8203;(<span class="arguments">double&nbsp;a1,
double&nbsp;a2)</span></div>
<div class="block">Computes the (signed) difference <i>a</i><sub>1</sub>-<i>a</i><sub>2</sub> of two angles <i>a</i><sub>1</sub>, <i>a</i><sub>2</sub>.
 The result is mapped to [-&pi;...&pi;].
 As a result, the difference is the angle difference, even tough the angles are counted around the 0 to 2&middot;&pi; border,
 e.g. diffRadians(0.1,2&middot;&pi;-0.1)==0.2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a1</code> - first angle in radians</dd>
<dd><code>a2</code> - second angle in radians</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>difference in radians</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="absDiffRadians(double,double)">absDiffRadians</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">absDiffRadians</span>&#8203;(<span class="arguments">double&nbsp;a1,
double&nbsp;a2)</span></div>
<div class="block">Same as <a href="#diffRadians(double,double)"><code>diffRadians(double,double)</code></a>, but takes the absolute value of angle difference.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a1</code> - first angle in radians</dd>
<dd><code>a2</code> - second angle in radians</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>absolute difference in radians</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="minRadiansBetweenLines(double,double)">minRadiansBetweenLines</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">minRadiansBetweenLines</span>&#8203;(<span class="arguments">double&nbsp;a1,
double&nbsp;a2)</span></div>
<div class="block"><p>Return the (absolute) smallest angle difference between two lines, given bei their line angles. The smallest angle difference
 is given by the four angles produces around the intersection point, where two opposite angles are equal.</p>
 As a line has 'two directions' (i.e. original angle and original angle plus 180&deg;), the minimum angle is thus computed by<pre>
 Math.min(absDiffRadians(a1-a2),
          absDiffRadians(Math.PI+a1-a2));
 </pre></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a1</code> - first angle in radians</dd>
<dd><code>a2</code> - second angle in radians</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>absolute difference in radians</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="reduceRadians(double)">reduceRadians</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double</span>&nbsp;<span class="memberName">reduceRadians</span>&#8203;(<span class="arguments">double&nbsp;angle)</span></div>
<div class="block">Maps an angle in the range of -5&middot;&pi;...+5&middot;&pi; in the range &plusmn;&pi;.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angle</code> - an angle</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the same angle in the range &plusmn;&pi;</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="bisectings(double,double)">bisectings</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">bisectings</span>&#8203;(<span class="arguments">double&nbsp;a1,
double&nbsp;a2)</span></div>
<div class="block">Computes the bisectings between two angles, i.e. the angles with the same difference to both angles.
 Note that there are always two bisectings. The result is ordered: [0] contains the angle with the smaller same difference, [1] with the larger same difference to the given angles.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a1</code> - first angle in radians</dd>
<dd><code>a2</code> - second angle in radians</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 2 with [0] bisecting of smaller spawned angle, [1] bisecting of larger spawned angle (i.e. [0] &plusmn;180&deg;)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="reduceDensityAngles(basics.util.DoubleArrayList,double)">reduceDensityAngles</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">reduceDensityAngles</span>&#8203;(<span class="arguments"><a href="../util/DoubleArrayList.html" title="class in basics.util">DoubleArrayList</a>&nbsp;angles,
double&nbsp;removeDiff)</span></div>
<div class="block">Reduce the density of an unordered list of angles. The reduction is made as follows:
 <ul>
  <li>loop through all listed angles</li>
  <li>second loop through all listed angles in the list after the first angle</li>
  <li>whenenever the difference is smaller than a given value, remove the seconds angle.</li>
 </ul>
 Note that the complexity is O(n<sup>2</sup>).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>angles</code> - list of angles (radians)</dd>
<dd><code>removeDiff</code> - difference up to which pairs are reduced (radians)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mostDistant(java.util.ArrayList)">mostDistant</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName">mostDistant</span>&#8203;(<span class="arguments">java.util.ArrayList&lt;double[]&gt;&nbsp;points)</span></div>
<div class="block">Computes the pair of most distance points according to <a href="Matrix.html#distance(double%5B%5D,double%5B%5D)"><code>Matrix.distance(double[],double[])</code></a>.
 The points may have any (but all same) dimension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - list of points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two integers with the respective indexes</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="mostDistant(double[][])">mostDistant</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">int[]</span>&nbsp;<span class="memberName">mostDistant</span>&#8203;(<span class="arguments">double[][]&nbsp;points)</span></div>
<div class="block">Computes the pair of most distance points according to <a href="Matrix.html#distance(double%5B%5D,double%5B%5D)"><code>Matrix.distance(double[],double[])</code></a>.
 The points may have any (but all same) dimension.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - list of points</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of two integers with the respective indexes</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="douglasPeucker(double[][],double)">douglasPeucker</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">java.util.ArrayList&lt;double[]&gt;</span>&nbsp;<span class="memberName">douglasPeucker</span>&#8203;(<span class="arguments">double[][]&nbsp;points,
double&nbsp;epsilon)</span></div>
<div class="block">Performs the <i>Douglas Peucker</i> line simplifyer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - list of points (2D)</dd>
<dd><code>epsilon</code> - the minimal distance of a line string point to the straight line to keep a point</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>simplfied line string</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="douglasPeucker(double[][],int,int,double)">douglasPeucker</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">java.util.ArrayList&lt;double[]&gt;</span>&nbsp;<span class="memberName">douglasPeucker</span>&#8203;(<span class="arguments">double[][]&nbsp;points,
int&nbsp;fromIndex,
int&nbsp;toIndex,
double&nbsp;epsilon)</span></div>
<div class="block">Performs the <i>Douglas Peucker</i> line simplifyer for a sub list of points.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>points</code> - list of points (2D)</dd>
<dd><code>fromIndex</code> - first point</dd>
<dd><code>toIndex</code> - last point (included!)</dd>
<dd><code>epsilon</code> - the minimal distance of a line string point to the straight line to keep a point</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>simplfied line string</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="arcBetweenPoses(double,double,double,double,double,double)">arcBetweenPoses</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">arcBetweenPoses</span>&#8203;(<span class="arguments">double&nbsp;sx,
double&nbsp;sy,
double&nbsp;sang,
double&nbsp;tx,
double&nbsp;ty,
double&nbsp;tang)</span>
                                throws <span class="exceptions">java.lang.IllegalArgumentException</span></div>
<div class="block">Compute an arc (center, rad) from two poses (start, targe).
 <ul>
   <li>Start and target orienation have same angle to the arc center</li>
   <li>Start and target positions have same distance to the arc center</li>
 </ul><br>
 <img src="arcfromposes.png" alt="arc from poses" width="60%" height="60%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>sx</code> - start pose x</dd>
<dd><code>sy</code> - start pose y</dd>
<dd><code>sang</code> - start pose orientation angle (radians)</dd>
<dd><code>tx</code> - target pose x</dd>
<dd><code>ty</code> - target pose y</dd>
<dd><code>tang</code> - target pose orientation angle (radians)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 3 with [0]: center x, [1]: center y, [2]: arc radius, [3]: angle difference target-start; null, if no arc can be computed</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="relativePose(double,double,double,double,double,double)">relativePose</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">relativePose</span>&#8203;(<span class="arguments">double&nbsp;fromX,
double&nbsp;fromY,
double&nbsp;fromAngle,
double&nbsp;toX,
double&nbsp;toY,
double&nbsp;toAngle)</span></div>
<div class="block">Compute the relative pose between two poses. I.e., it is the second pose, if we assume the first pose with coordinates (0,0,0&deg;).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fromX</code> - start position x</dd>
<dd><code>fromY</code> - start position y</dd>
<dd><code>fromAngle</code> - start angle in radians</dd>
<dd><code>toX</code> - target position x</dd>
<dd><code>toY</code> - target position y</dd>
<dd><code>toAngle</code> - target angle in radians</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 3 with [0]: relative x, [1]: relative y, [2]: relative orientation</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="maxDescent(double,double)">maxDescent</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">maxDescent</span>&#8203;(<span class="arguments">double&nbsp;tiltAngleXZ,
double&nbsp;tiltAngleYZ)</span></div>
<div class="block"><p>Compute the direction of maximum descent from the two tilt (Euler) angles.
 This method is a approximation of the exact approach as it expects small angles (say smaller than &plusmn;10&deg;).
 This allows to consider both rotations as applied 'in parallel' not one after the other.</p>
 The direction of maximum descent can be defined by two angles:<ul>
 <li>&beta;: the direction in the x-y-plane (i.e. viewed from above)</li>
 <li>&gamma;: the angle below horizon</li>
 </ul>
 In addition, we can compute the 3D viewing vector (x<sub>d</sub>, y<sub>d</sub>, z<sub>d</sub>)<br>
 <img src="maxdescent.png" alt="max. descent" width="30%" height="30%"></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tiltAngleXZ</code> - tilt angle in the x-z-plane (i.e. Roll angle)</dd>
<dd><code>tiltAngleYZ</code> - tilt angle in the y-z-plane (i.e. Pitch angle)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>array of 5 with: <ul>
  <li>[0]: &beta; </li>
  <li>[1]: &gamma; </li>
  <li>[2]: x<sub>d</sub></li>
  <li>[3]: y<sub>d</sub></li>
  <li>[4]: z<sub>d</sub></li>
 </ul></dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="project3Dto3D(double[],double[],double[],double[],double[],boolean)">project3Dto3D</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">project3Dto3D</span>&#8203;(<span class="arguments">double[]&nbsp;point,
double[]&nbsp;zero,
double[]&nbsp;xAxis,
double[]&nbsp;yAxis,
double[]&nbsp;zAxis,
boolean&nbsp;checkAxis)</span></div>
<div class="block">Given a point in a our 'normal' (xzy) coordinate system. Transform it to a given coordinate system with zero point and axis vectors.
 How is this point expressed in this new coordinate system?<br>
 In more detail. For p look for a p' that holds:<br>
 p=p'<sub>x</sub>&middot;xAxis+p'<sub>y</sub>&middot;yAxis+p'<sub>z</sub>&middot;zAxis+zero<br>
 <i>Note: </i> to get unique coordinates it is required that all axis are right-angled to each others. If checkAxis==true, this will be checked.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - point in xyz coordinates</dd>
<dd><code>zero</code> - zero point of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>xAxis</code> - x-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>yAxis</code> - y-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>zAxis</code> - z-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>checkAxis</code> - if true, this method checks if given axes are right-angled</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>same point in (zero,xAxis,yAxis,zAxis) coordinates</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="project3Dto3Dinv(double[],double[],double[],double[],double[],boolean)">project3Dto3Dinv</a></h3>
<div class="memberSignature"><span class="modifiers">public static</span>&nbsp;<span class="returnType">double[]</span>&nbsp;<span class="memberName">project3Dto3Dinv</span>&#8203;(<span class="arguments">double[]&nbsp;point,
double[]&nbsp;zero,
double[]&nbsp;xAxis,
double[]&nbsp;yAxis,
double[]&nbsp;zAxis,
boolean&nbsp;checkAxis)</span></div>
<div class="block">Given a point p' in coordinates according (zero,xAxis,yAxis,zAxis), what are the coordinates in our 'normal' (xzy) coordinate system?<br>
 Thus, we have to compute
 p=p'<sub>x</sub>&middot;xAxis+p'<sub>y</sub>&middot;yAxis+p'<sub>z</sub>&middot;zAxis+zero<br></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>point</code> - point in (zero,xAxis,yAxis,zAxis) coordinates</dd>
<dd><code>zero</code> - zero point of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>xAxis</code> - x-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>yAxis</code> - y-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>zAxis</code> - z-axis vector of the new coordinate system (expressed in xyz-coordinates)</dd>
<dd><code>checkAxis</code> - if true, this method checks if given axes are right-angled</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>same point in xyz coordinates</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
